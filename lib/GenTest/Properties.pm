# Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights
# reserved.
# Copyright (c) 2018, 2022, MariaDB Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
# USA

## Handling of config properties and options
##
## default: Default values
## options: The hashgenerated by Getoptions
## required: required properties
## legal: additional legal properties. The final set of legal
##        properties is the union between default, options, required
##        and legal.
## legal and required is not (yet) recursive defined.
##
## Usage:
## my $options = {}
## GetOptions($options,'config=s'................);
## my $config=GenTest::Properties->new(options=>$options......);

##
package GenTest::Properties;

@ISA = qw(GenTest);

use strict;
use Carp;
use GenUtil;
use GenTest;
use Constants;

use Data::Dumper;

use constant PROPS_NAME => 0;
use constant PROPS_DEFAULTS => 1; ## Default values
use constant PROPS_OPTIONS => 2;  ## Legal options to check for
use constant PROPS_HELP => 3;     ## Help text
use constant PROPS_LEGAL => 4;    ## List of legal properies
use constant PROPS_LEGAL_HASH => 5; ## Hash of legal properties
use constant PROPS_REQUIRED => 6; ## Required properties
use constant PROPS_PROPS => 7;    ## the actual properties
use constant PROPS_HASH_BACKUP => 8; ## Initial hash to use as a backup

1;

##
## AUTOLOAD function intercepts all calls to undefined methods. Use
## (if defined) PROPS_LEGAL_HASH to decide if the wanted property is
## legal. All intercpeted method calls will return
## $self->[PROPS_PROPS]->{$name}

sub AUTOLOAD {
    my ($self,$arg) = @_;
    my $name = our $AUTOLOAD;
    $name =~ s/.*:://;

    ## Avoid catching DESTRY et.al. (no intercepted calls to methods
    ## starting with an uppercase letter)
    return unless $name =~ /[^A-Z]/;

    $self->[PROPS_PROPS]->{$name} = $arg if defined $arg;
    return $self->[PROPS_PROPS]->{$name};
}

## Constructor

sub new {
    my $class = shift;

  my $props = $class->SUPER::new({
      'name' => PROPS_NAME,
      'defaults'  => PROPS_DEFAULTS,
      'required'  => PROPS_REQUIRED,
      'options' => PROPS_OPTIONS,
      'legal' => PROPS_LEGAL,
      'help' => PROPS_HELP ## disabled since I get weird warning....
       }, @_);

    ## List of legal properties, if no such list, all properties are
    ## legal. The PROPS_LEGAL_HASH becomes the union of PROPS_LEGAL,
    ## PROPS_REQURED, PROPS_OPTIONS (specified on command line and
    ## decided from argument to getoptions) and PROPS_DEFAULTS

    if (defined $props->[PROPS_LEGAL]) {
        foreach my $legal (@{$props->[PROPS_LEGAL]}) {
            $props->[PROPS_LEGAL_HASH]->{$legal}=1;
        }
    }

    if (defined $props->[PROPS_REQUIRED]) {
        foreach my $legal (@{$props->[PROPS_REQUIRED]}) {
            $props->[PROPS_LEGAL_HASH]->{$legal}=1;
        }
    }

    if (defined $props->[PROPS_OPTIONS]) {
        foreach my $legal (keys %{$props->[PROPS_OPTIONS]}) {
            $props->[PROPS_LEGAL_HASH]->{$legal}=1;
        }
    }
    if (defined $props->[PROPS_DEFAULTS]) {
        foreach my $legal (keys %{$props->[PROPS_DEFAULTS]}) {
            $props->[PROPS_LEGAL_HASH]->{$legal}=1;
        }
    }


    ## Pick up defaults

    my $defaults = $props->[PROPS_DEFAULTS];
    $defaults = {} if not defined $defaults;

    ## Pick op command line uptions

    my $from_cli = $props->[PROPS_OPTIONS];
    $from_cli = {} if not defined $from_cli;

    ## Pick up settings from config file if present

    my $from_file = {};

    if ($from_cli->{config}) {
        $from_file = _readProps($from_cli->{config});
    }

    ## Calculate settings.
    ## 1: Let defaults be overridden by configfile
    $props->[PROPS_PROPS] = _mergeProps($defaults, $from_file);
    ## 2: Let the command line options override the mege of the two
    ## above
    $props->[PROPS_PROPS] = _mergeProps($props->[PROPS_PROPS], $from_cli);

    ## Check for illegal properties
    ##
    my @illegal;
    if (defined $props->[PROPS_LEGAL_HASH]) {
        foreach my $p (keys %{$props->[PROPS_PROPS]}) {
            if (not exists $props->[PROPS_LEGAL_HASH]->{$p}) {
                push(@illegal,$p);
            }
        }
    }
    ## Check if all required properties are set.
    my @missing;
    if (defined $props->[PROPS_REQUIRED]) {
        foreach my $p (@{$props->[PROPS_REQUIRED]}) {
            push (@missing, $p) if not exists $props->[PROPS_PROPS]->{$p};
        }
    }

    my $message;
    $message .= "The following properties are not legal: ".
        join(", ", map {"'--".$_."'"} sort @illegal). ". " if $#illegal >= 0;

    $message .= "The following required properties  are missing: ".
        join(", ", map {"'--".$_."'"} sort @missing). ". " if $#missing >= 0;

    if (defined $message) {
        $props->_help();
        croak($message);
    }

    return $props;
}

sub init {
  my ($class, $props)= @_;
  my $gentestProps= $class->new(
    legal => [
              'base_port',
              'grammars',
              'dsn',
              'engine',
              'gendata',
              'generator',
              'gis',
              'redefines',
              'threads',
              'queries',
              'duration',
              'help',
              'debug',
              'validators',
              'reporters',
              'transformers',
              'variators',
              'seed',
              'metadata_reload',
              'rows',
              'vcols',
              'views',
              'filters',
              'short_column_names',
              'server_specific',
              'freeze_time',
              'valgrind',
              'rr',
              'sqltrace',
              'servers',
              'multi-master',
              'annotate-rules',
              'restart-timeout',
              'ps-protocol',
              'partitions',
              'compatibility',
              'compatibility_es',
              'user',
              'parser',
              'parser_mode',
              'perf',
              'uhashkeys',
      ]
  );

  $gentestProps->setPropertiesFromHash($props);
  $gentestProps->backupProperties();
  return $gentestProps;
}

sub backupProperties {
  $_[0]->[PROPS_HASH_BACKUP]= { %{$_[0]->[PROPS_PROPS]} };
}

sub restoreProperties {
  $_[0]->setPropertiesFromHash($_[0]->[PROPS_HASH_BACKUP]);
}

sub setPropertiesFromHash {
  my ($gentestProps, $props)= @_;

  $gentestProps->property('annotate-rules',$props->{annotate_rules}) if defined $props->{annotate_rules};
  $gentestProps->property('base_port',$props->{base_port}) if defined $props->{base_port};
  $gentestProps->property('debug',1) if defined $props->{debug};
  $gentestProps->property('duration',$props->{duration}) if defined $props->{duration};
  $gentestProps->property('engine',$props->{engine}) if $props->{engine};
  $gentestProps->property('filters',$props->{filters}) if defined $props->{filters};
  $gentestProps->property('freeze_time',$props->{freeze_time}) if defined $props->{freeze_time};
  $gentestProps->property('gendata',$props->{gendata}) if exists $props->{gendata};
  $gentestProps->property('generator',($props->{generator} || 'FromGrammar'));
  $gentestProps->property('gis',1) if defined $props->{gis};
  $gentestProps->property('grammars',$props->{grammars});
  $gentestProps->property('queries',$props->{queries}) if defined $props->{queries};
  $gentestProps->property('metadata_reload',(defined $props->{metadata_reload} ? $props->{metadata_reload} : 1)); # By default metadata is loaded
  $gentestProps->property('multi-master',1) if $props->{'multi-master'};
  $gentestProps->property('parser',$props->{parser});
  $gentestProps->property('parser_mode',$props->{parser_mode});
  $gentestProps->property('ps-protocol',1) if $props->{ps_protocol};
  $gentestProps->property('redefines',$props->{redefines}) if $props->{redefines};
  $gentestProps->property('reporters',$props->{reporters}) if $props->{reporters};
  $gentestProps->property('rows',$props->{rows}) if defined $props->{rows};
  $gentestProps->property('seed',$props->{seed}) if defined $props->{seed};
  $gentestProps->property('server_specific',$props->{server_specific}) if $props->{server_specific};
  $gentestProps->property('short_column_names',$props->{short_column_names}) if defined $props->{short_column_names};
  $gentestProps->property('sqltrace',$props->{sqltrace}) if $props->{sqltrace};
  $gentestProps->property('threads',$props->{threads}) if defined $props->{threads};
  $gentestProps->property('transformers',$props->{transformers}) if $props->{transformers};
  $gentestProps->property('variators',$props->{variators}) if $props->{variators};
  $gentestProps->property('valgrind',1) if $props->{valgrind};
  $gentestProps->property('rr',1) if $props->{rr};
  $gentestProps->property('perf',1) if $props->{perf};
  $gentestProps->property('validators',$props->{validators}) if $props->{validators};
  $gentestProps->property('vcols',$props->{vcols}) if $props->{vcols};
  $gentestProps->property('views',$props->{views}) if $props->{views};
  $gentestProps->property('partitions',$props->{partitions}) if defined $props->{partitions};
  $gentestProps->property('compatibility',$props->{compatibility}) if defined $props->{compatibility};
  $gentestProps->property('compatibility_es',$props->{compatibility_es}) if $props->{compatibility_es};
  $gentestProps->property('user',$props->{user}) if defined $props->{user};
  $gentestProps->property('vardir',$props->{vardir}) if defined $props->{vardir};
  $gentestProps->property('uhashkeys',1) if defined $props->{uhashkeys};

  # In case of multi-master topology (e.g. Galera with multiple "masters"),
  # we don't want to compare results after each query.
  # Instead, we want to run the flow independently and only compare dumps at the end.
  # If GenTest gets 'multi-master' property, it won't run ResultsetComparator

  $gentestProps->property('multi-master',1) if (defined $props->{galera});

  return $gentestProps;
}


## Basic set/get method. Note that $x->property('string') is the same
## as $x->string and that $x->property('string', value) is the same as
## $x->string(value). Useful for propertys that can't be perl
## subroutine names.

sub property {
    my ($self, $name, $arg) = @_;

    $self->[PROPS_PROPS]->{$name} = $arg if defined $arg;
    return $self->[PROPS_PROPS]->{$name};

}
# Since the basic set/get cannot set a property to 'undef',
# we need a separate method to unset an existing property
sub unsetProperty {
    my ($self, $name) = @_;

    if (defined $self->[PROPS_LEGAL_HASH]) {
        croak("Illegal property '$name' caught by AUTOLOAD ")
            if not $self->[PROPS_LEGAL_HASH]->{$name};
    }

    $self->[PROPS_PROPS]->{$name} = undef;
    return $self->[PROPS_PROPS]->{$name};
}
## Read properties from a given file
sub _readProps {
    my ($file) = @_;
    open(PFILE, $file) or croak "Unable to read properties file '$file': $!";
    read(PFILE, my $propfile, -s $file);
    close PFILE;
    my $props = eval($propfile);
    croak "Unable to load $file: $@" if $@;
    return $props;
}

## Merge properties recursively
sub _mergeProps {
    my ($a,$b) = @_;

    # First recursively deal with hashes
    my $mergedHashes = {};
    foreach my $h (keys %$a) {
        if (UNIVERSAL::isa($a->{$h},"HASH")) {
            if (defined $b->{$h}) {
                $mergedHashes->{$h} = _mergeProps($a->{$h},$b->{$h});
            }
        }
    }
    # The merge
    my $result = {%$a, %$b};
    $result = {%$result,  %$mergedHashes};
    return $result;
}

## Global print method
sub printProps {
    my ($self) = @_;
    $Data::Dumper::Maxdepth= 3;
    $Data::Dumper::Sortkeys= 1;
    $Data::Dumper::Ident= 0;
}

## Help routine!
sub _help {
    my ($self) = @_;

    if (defined $self->[PROPS_HELP]) {
        if (UNIVERSAL::isa($self->[PROPS_HELP],"CODE")) {
            ## Help routine provided
            &{$self->[PROPS_HELP]};
        } else {
            ## Help text provided
            print $self->[PROPS_HELP]."\n";
        }
    } else {
        ## Generic help (not very helpful, but better than nothing).
        print "$0 - Legal properties/options:\n";
        my $required = {map {$_=>1} @{$self->[PROPS_REQUIRED]}};
        foreach my $k (sort keys %{$self->[PROPS_LEGAL_HASH]}) {
            ## Required, command line options etc should be marked.
            print "    --$k ".(defined $required->{$k}?"(required)":"").",\n";
        }
    }
}

1;
