# Copyright 2020, 2023, MariaDB
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
# USA


########################################################################
#
# The module implements a crash recovery scenario for Atomic DDL.
#
# The scenario runs in one of two variants, selected based on server
# options:
# - in both variants the test first runs some DDL flow (or whatever flow
#   is generated by grammars) and crashes the server in the process;
# - further the test restarts the server and checks the schema health
# - if the original server configuration involves binary logging,
#   then the test additionally runs a copy of the original server as
#   a slave, waits for binlogs to be replicated, and compares the
#   databases on the main server after crash recovery and on the slave
#   after replication
#
########################################################################

package GenTest::Scenario::AtomicDDL;

require Exporter;
@ISA = qw(GenTest::Scenario);

use strict;
use GenUtil;
use GenTest;
use GenTest::TestRunner;
use GenTest::Properties;
use Constants;
use GenTest::Scenario;
use GenTest::Scenario::Upgrade;
use GenTest::Random;
use Data::Dumper;
use File::Copy;
use File::Compare;
use POSIX;

use DBServer::MariaDB;
use Connection::Perl;

sub new {
  my $class= shift;
  my $self= $class->SUPER::new(@_);
  # Only 1 server to be used
  $self->numberOfServers(1,1);
  return $self;
}

sub run {
  my $self= shift;
  my ($status, $server, $slave, $databases, $general_log_file);
  my ($datadir, $datadir_before_recovery);
  my $prng = $self->prng;

  $status= STATUS_OK;

  #####
  # Prepare server(s)

  $server= $self->prepareServer(1, my $is_active=1);

  # If the test is running with binary log enabled, we will use replication
  # for binlog consistency check. Otherwise the check will be skipped
  my @mysqld_options= @{$self->getServerSpecific(1)->{mysqld}};

  if ("@mysqld_options" =~ /--log[-_]bin[= ]|--log[-_]bin$/) {
    $self->copyServerSpecific(1,2);
    $self->setServerSpecific(2,'port',$self->getProperty('base_port') + 1);

    push @mysqld_options,
      '--server-id=999',
      '--secure-timestamp=REPLICATION',
      '--max-statement-time=0'
    ;
    $self->setServerSpecific(2,'mysqld',\@mysqld_options);
    $slave= $self->prepareServer(2, my $is_active=0);
  }

  $datadir= $server->datadir;
  $datadir_before_recovery= $datadir.'_before_recovery';

  #####
  $self->printStep("Starting the server");

  $status= $server->startServer;

  if ($status != STATUS_OK) {
    sayError("The server failed to start");
    $status= STATUS_SERVER_STARTUP_FAILURE if $status < STATUS_SERVER_STARTUP_FAILURE;
    goto FINALIZE;
  }

  $general_log_file= $server->serverVariable('general_log_file');
  unless ($general_log_file =~ /(?:\/|\\)/) {
    $general_log_file= $server->datadir.'/'.$general_log_file;
  }

  #####
  $self->printStep("Generating data");

  $status= $self->generateData();

  if ($status != STATUS_OK) {
    sayError("Data generation failed");
    goto FINALIZE;
  }

  #####

  my $timeout= $prng->int($self->getProperty('duration')/4,$self->getProperty('duration')/4*3);
  $self->printStep("Running the test flow (random duration: $timeout sec)");
  $self->createTestRunner();
  my $gentest_pid= fork();
  if (not defined $gentest_pid) {
    sayError("Failed to fork for atomic DDL");
    $status= STATUS_ENVIRONMENT_FAILURE if $status < STATUS_ENVIRONMENT_FAILURE;
    goto FINALIZE;
  }

  # The child will be running DDL. The parent will be running
  # the server and then killing it, and while waiting, will be monitoring
  # the status of the test flow to notice if it exits prematurely.

  if ($gentest_pid > 0) {
    foreach (1..$timeout) {
      if (waitpid($gentest_pid, WNOHANG) == 0) {
        sleep 1;
      }
      else {
        $status= $? >> 8;
        last;
      }
    }
  }
  else {
    my $res= $self->runTestFlow();
    exit $res;
  }

  if ($status != STATUS_OK) {
    sayError("Atomic DDL failed");
    goto FINALIZE;
  }

  #####
  my $signal= $prng->arrayElement(['KILL','ABRT','SEGV']);
  $self->printStep("Killing the server with $signal");
  $status= $server->startPlannedDowntime($signal,-1);

  if ($status != STATUS_OK) {
    sayError("Could not kill the server");
    $status= STATUS_SERVER_SHUTDOWN_FAILURE if $status < STATUS_SERVER_SHUTDOWN_FAILURE;
    goto FINALIZE;
  }

  # We don't care about the result of gentest after killing the server,
  # but we need to ensure that the process exited
  waitpid($gentest_pid, 0);

  #####
  $self->printStep("Backing up data directory");

  $server->backupDatadir($datadir_before_recovery);
  move($server->errorlog, $server->errorlog.'_before_recovery');
  if (-e $general_log_file) {
    move($general_log_file, $general_log_file.'_before_recovery');
  }

  #####
  $self->printStep("Restarting the server");

  $status= $server->startServer;

  if ($status != STATUS_OK) {
    sayError("Server failed to restart");
    # Error log might indicate known bugs which will affect the exit code
    $status= $self->checkErrorLog($server);
    # ... but even if it's a known error, we cannot proceed without the server
    goto FINALIZE;
  }

  $server->endPlannedDowntime();

  #####
  $self->printStep("Checking the server error log for errors after recovery");

  $status= $self->checkErrorLog($server);

  if ($status != STATUS_OK) {
    # Error log can show known errors. We want to update
    # the global status, but don't want to exit prematurely
    $self->setStatus($status);
    sayError("Found errors in the log after restart");
    if ($status > STATUS_CUSTOM_OUTCOME) {
      $status= STATUS_RECOVERY_FAILURE if $status < STATUS_RECOVERY_FAILURE;
      goto FINALIZE;
    }
  }

  my $master_dump_result= STATUS_OK;
  my ($master_conn, $slave_conn);
  my @databases;

  if ($slave) {
    #####
    $self->printStep("Dumping databases for further replication consistency check");

    @databases= $server->nonSystemDatabases();
    $master_dump_result= $server->dumpSchema(\@databases, $server->vardir.'/server_schema_recovered.dump');
    $server->normalizeDump($server->vardir.'/server_schema_recovered.dump', 'remove_autoincs');

    #####
    $self->printStep("Starting the slave");
    $status= $slave->startServer;

    if ($status != STATUS_OK) {
      sayError("Failed to start the slave");
      $status= STATUS_SERVER_STARTUP_FAILURE if $status < STATUS_SERVER_STARTUP_FAILURE;
      goto FINALIZE;
    }

    $slave_conn= Connection::Perl->new(server => $slave, name => 'ATO');
    if ($slave_conn) {
      $slave_conn->execute("CHANGE MASTER TO MASTER_HOST='127.0.0.1', MASTER_PORT=".$server->port.", MASTER_USER='root'");
      $slave_conn->execute("START SLAVE");
    } else {
      sayError("Could not connect to the slave");
      $status= STATUS_REPLICATION_FAILURE if $status < STATUS_REPLICATION_FAILURE;
      goto FINALIZE;
    }
  }

  #####
  $self->printStep("Checking the database state after restart");

  $status= $server->checkDatabaseIntegrity;

  if ($status != STATUS_OK) {
    sayError("Database appears to be corrupt after restart");
    $status= STATUS_RECOVERY_FAILURE if $status < STATUS_RECOVERY_FAILURE;
    goto FINALIZE;
  }

  if ($slave) {
    #####
    $self->printStep("Replicating the data");
    my ($file, $pos) = $server->getMasterPos();
    if ($file && $pos && $slave->syncWithMaster($file, $pos, $self->getProperty('duration')) == STATUS_OK) {
      $slave_conn->execute("STOP SLAVE");
    } else {
      $status= STATUS_REPLICATION_FAILURE if $status < STATUS_REPLICATION_FAILURE;
      goto FINALIZE;
    }
    #####
    $self->printStep("Dumping databases from the slave");

    @databases= $slave->nonSystemDatabases();
    $slave->dumpSchema(\@databases, $server->vardir.'/slave_schema.dump');
    $slave->normalizeDump($server->vardir.'/slave_schema.dump', 'remove_autoincs');

    #####
    $self->printStep("Comparing schemata on master and slave");

    $status= compare($server->vardir.'/server_schema_recovered.dump', $server->vardir.'/slave_schema.dump');
    if ($status != STATUS_OK) {
      sayError("Database structures differ");
      system('diff -a -u '.$server->vardir.'/server_schema_recovered.dump'.' '.$server->vardir.'/slave_schema.dump');
      $status= STATUS_RECOVERY_FAILURE if $status < STATUS_RECOVERY_FAILURE;
      goto FINALIZE;
    }
    else {
      say("Structure dumps appear to be identical");
    }
  }

FINALIZE:
  return $self->finalize($status,($slave ? [$server,$slave] : [$server]));
}

1;
